"use strict";const DIRECTION_NONE="0",DIRECTION_LEFT="left",DIRECTION_RIGHT="right",DIRECTION_UP="up",DIRECTION_DOWN="down",DIRECTION_CLOCKWISE=1,DIRECTION_COUNTER_CLOCKWISE=-1,DIRECTION_HORIZONTAL=[DIRECTION_LEFT,DIRECTION_RIGHT],DIRECTION_VERTICAL=[DIRECTION_UP,DIRECTION_DOWN],DIRECTION_ALL=[DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN],GESTURE_STATE_POSSIBLE="possible",GESTURE_STATE_BLOCKED="blocked";class Contact{constructor(pointerdownEvent,options){options=options||{},this.options={DEBUG:!1};for(let key in options)this.options[key]=options[key];this.DEBUG=this.options.DEBUG,this.id=(new Date).getTime(),this.pointerInputs={},this.activePointerInputs={},this.primaryPointerId=pointerdownEvent.pointerId,this.initialPointerEvent=pointerdownEvent,this.currentPointerEvent=pointerdownEvent,this.addPointer(pointerdownEvent),this.isActive=!0,this.startTimestamp=pointerdownEvent.timeStamp,this.currentTimestamp=this.startTimestamp,this.endTimestamp=null,this.multipointer={liveParameters:{centerMovement:null,centerMovementVector:null,distanceChange:null,relativeDistanceChange:null,rotationAngle:null,vectorAngle:null},globalParameters:{centerMovement:null,centerMovementVector:null,distanceChange:null,relativeDistanceChange:null,rotationAngle:null,vectorAngle:null}}}addPointer(pointerdownEvent){this.currentPointerEvent=pointerdownEvent;var pointerInputOptions={DEBUG:this.DEBUG},pointerInput=new PointerInput(pointerdownEvent,pointerInputOptions);this.pointerInputs[pointerdownEvent.pointerId]=pointerInput,this.activePointerInputs[pointerdownEvent.pointerId]=pointerInput}removePointer(pointerId){delete this.activePointerInputs[pointerId]}getPointerInput(pointerId){if(Object.prototype.hasOwnProperty.call(this.pointers,pointerId)){return this.pointers[pointerId]}throw new Error("invalid pointerId: "+pointerId+". Pointer not found in Contact.pointers")}getPrimaryPointerInput(){return this.pointerInputs[this.primaryPointerId]}getMultiPointerInputs(){var pointerId_1=Object.keys(this.activePointerInputs)[0],pointerInput_1=this.activePointerInputs[pointerId_1],pointerId_2=Object.keys(this.activePointerInputs)[1];return[pointerInput_1,this.activePointerInputs[pointerId_2]]}onPointerMove(pointermoveEvent){this.currentPointerEvent=pointermoveEvent,this.currentTimestamp=pointermoveEvent.timeStamp,this.pointerInputs[pointermoveEvent.pointerId].onMove(pointermoveEvent),!0===this.DEBUG&&console.log(this.pointerInputs),this.updateState()}onPointerUp(pointerupEvent){var pointerId=pointerupEvent.pointerId;this.currentPointerEvent=pointerupEvent,this.currentTimestamp=pointerupEvent.timeStamp;var removedPointer=this.pointerInputs[pointerId];removedPointer&&removedPointer.onUp(pointerupEvent),this.removePointer(pointerId),this.updateState()}onPointerCancel(pointercancelEvent){this.onPointerUp(pointercancelEvent),1==this.DEBUG&&console.log("[Contact] pointercancel detected")}onPointerLeave(pointerleaveEvent){this.onPointerUp(pointerleaveEvent),1==this.DEBUG&&console.log("[Contact] pointerleave detected")}onIdle(){for(let pointerInputId in this.activePointerInputs){this.activePointerInputs[pointerInputId].onIdle()}}updateState(){var isActive=!1;Object.keys(this.activePointerInputs).length>0&&(isActive=!0),this.isActive=isActive,0==this.isActive?this.endTimestamp=this.currentTimestamp:Object.keys(this.activePointerInputs).length>=2&&this.updateMultipointerParameters()}updateMultipointerParameters(){var multiPointerInputs=this.getMultiPointerInputs(),pointerInput_1=multiPointerInputs[0],pointerInput_2=multiPointerInputs[1],vector_1=pointerInput_1.liveParameters.vector,vector_2=pointerInput_2.liveParameters.vector;if(null!=vector_1&&null!=vector_2){var currentCenter=getCenter(vector_1.startPoint,vector_2.startPoint);this.multipointer.liveParameters.center=currentCenter;var centerMovementVector=this.calculateCenterMovement(vector_1,vector_2);this.multipointer.liveParameters.centerMovementVector=centerMovementVector,this.multipointer.liveParameters.centerMovement=centerMovementVector.vectorLength;var liveDistanceChange=this.calculateDistanceChange(vector_1,vector_2);this.multipointer.liveParameters.distanceChange=liveDistanceChange.absolute,this.multipointer.liveParameters.relativeDistanceChange=liveDistanceChange.relative;var liveRotationAngle=this.calculateRotationAngle(vector_1,vector_2);this.multipointer.liveParameters.rotationAngle=liveRotationAngle;var liveVectorAngle=this.calculateVectorAngle(vector_1,vector_2);this.multipointer.liveParameters.vectorAngle=liveVectorAngle}var globalVector_1=pointerInput_1.globalParameters.vector,globalVector_2=pointerInput_2.globalParameters.vector;if(null!=globalVector_1&&null!=globalVector_2){var globalCenter=getCenter(globalVector_1.startPoint,globalVector_2.startPoint);this.multipointer.globalParameters.center=globalCenter;var globalCenterMovementVector=this.calculateCenterMovement(globalVector_1,globalVector_2);this.multipointer.globalParameters.centerMovementVector=globalCenterMovementVector,this.multipointer.globalParameters.centerMovement=globalCenterMovementVector.vectorLength;var globalDistanceChange=this.calculateDistanceChange(globalVector_1,globalVector_2);this.multipointer.globalParameters.distanceChange=globalDistanceChange.absolute,this.multipointer.globalParameters.relativeDistanceChange=globalDistanceChange.relative;var globalRotationAngle=this.calculateRotationAngle(globalVector_1,globalVector_2);this.multipointer.globalParameters.rotationAngle=globalRotationAngle;var globalVectorAngle=this.calculateVectorAngle(globalVector_1,globalVector_2);this.multipointer.liveParameters.vectorAngle=globalVectorAngle}!0===this.DEBUG&&(console.log("[Contact] 2 fingers: centerMovement between pointer #"+pointerInput_1.pointerId+" and pointer #"+pointerInput_2.pointerId+" : "+this.multipointer.liveParameters.centerMovement+"px"),console.log("[Contact] 2 fingers: distanceChange: between pointer #"+pointerInput_1.pointerId+" and pointer #"+pointerInput_2.pointerId+" : "+this.multipointer.liveParameters.distanceChange+"px"),console.log("[Contact] 2 fingers live angle: "+this.multipointer.liveParameters.rotationAngle+"deg"),console.log("[Contact] 2 fingers global angle: "+this.multipointer.globalParameters.rotationAngle+"deg"))}calculateCenterMovement(vector_1,vector_2){var startPoint=getCenter(vector_1.startPoint,vector_2.startPoint),endPoint=getCenter(vector_1.endPoint,vector_2.endPoint);return new Vector(startPoint,endPoint)}calculateDistanceChange(vector_1,vector_2){var vectorBetweenStartPoints=new Vector(vector_1.startPoint,vector_2.startPoint),vectorBetweenEndPoints=new Vector(vector_1.endPoint,vector_2.endPoint);return{absolute:vectorBetweenEndPoints.vectorLength-vectorBetweenStartPoints.vectorLength,relative:vectorBetweenEndPoints.vectorLength/vectorBetweenStartPoints.vectorLength}}calculateRotationAngle(vector_1,vector_2){var angleVector_1=new Vector(vector_1.startPoint,vector_2.startPoint),angleVector_2=new Vector(vector_1.endPoint,vector_2.endPoint),origin=new Point(0,0),translationVector_1=new Vector(angleVector_1.startPoint,origin),translatedEndPoint_1=translatePoint(angleVector_1.endPoint,translationVector_1),translationVector_2=new Vector(angleVector_2.startPoint,origin),translatedEndPoint_2=translatePoint(angleVector_2.endPoint,translationVector_2),rotationAngle=-1*calcAngleRad(translatedEndPoint_1),x_2_rotated=translatedEndPoint_2.x*Math.cos(rotationAngle)-translatedEndPoint_2.y*Math.sin(rotationAngle),y_2_rotated=Math.round(translatedEndPoint_2.x*Math.sin(rotationAngle)+translatedEndPoint_2.y*Math.cos(rotationAngle));return 180*Math.atan2(y_2_rotated,x_2_rotated)/Math.PI}calculateVectorAngle(vector_1,vector_2){var angleDeg=null;if(vector_1.vectorLength>0&&vector_2.vectorLength>0){var cos=(vector_1.x*vector_2.x+vector_1.y*vector_2.y)/(vector_1.vectorLength*vector_2.vectorLength);angleDeg=rad2deg(Math.acos(cos))}return angleDeg}}class PointerInput{constructor(pointerdownEvent,options){options=options||{},this.options={DEBUG:!1};for(let key in options)this.options[key]=options[key];this.DEBUG=this.options.DEBUG;var now=(new Date).getTime();this.pointerId=pointerdownEvent.pointerId;var hasVectorTimespan=Object.prototype.hasOwnProperty.call(this.options,"vectorTimespan");this.vectorTimespan=1==hasVectorTimespan?this.options.vectorTimespan:100,this.initialPointerEvent=pointerdownEvent,this.currentPointerEvent=pointerdownEvent,this.recognizedEvents=[pointerdownEvent],this.canceled=!1,this.isActive=!0;var nullVector=this.getVector(pointerdownEvent,pointerdownEvent);this.liveParameters={vector:nullVector,speed:0,isMoving:!1},this.globalParameters={startX:this.initialPointerEvent.clientX,startY:this.initialPointerEvent.clientY,vector:nullVector,deltaX:0,deltaY:0,startTimestampUTC:now,startTimestamp:this.initialPointerEvent.timeStamp,currentTimestamp:this.initialPointerEvent.timeStamp,endTimestamp:null,maximumSpeed:0,averageSpeed:0,finalSpeed:null,traveledDistance:0,hasBeenMoved:!1,duration:0}}onIdle(){let duration=(new Date).getTime()-this.globalParameters.startTimestampUTC;this.globalParameters.duration=duration}onMove(pointermoveEvent){this.globalParameters.hasBeenMoved=!0,this.liveParameters.isMoving=!0,this.update(pointermoveEvent,!0)}onUp(pointerupEvent){this.globalParameters.finalSpeed=this.liveParameters.speed,this.liveParameters.currentSpeed=0,this.liveParameters.isMoving=!1,this.isActive=!1,this.globalParameters.endTimestamp=pointerupEvent.timeStamp,this.update(pointerupEvent),!0===this.DEBUG&&console.log("[Contact] pointerdown ended. pointerdown duration: "+this.globalParameters.duration+"ms")}onCancel(pointercancelEvent){this.update(pointercancelEvent),this.liveParameters.speed=0,this.canceled=!0,this.liveParameters.isMoving=!1,this.isActive=!1,this.globalParameters.endTimestamp=pointercancelEvent.timeStamp,!0===this.DEBUG&&console.log("[Contact] canceled, pointerdown duration:"+this.duration)}update(pointerEvent){this.currentPointerEvent=pointerEvent,this.recognizedEvents.push(pointerEvent);var timedPointerEvents=this.getTimedPointerEvents(),liveVector=this.getVector(timedPointerEvents[0],timedPointerEvents[1]);if(this.liveParameters.vector=liveVector,null!=liveVector){this.liveParameters.speed=this.getSpeed(liveVector,timedPointerEvents[0].timeStamp,timedPointerEvents[1].timeStamp),this.liveParameters.speed>this.globalParameters.maximumSpeed&&(this.globalParameters.maximumSpeed=this.liveParameters.speed),this.globalParameters.currentTimestamp=pointerEvent.timeStamp,this.globalParameters.duration=pointerEvent.timeStamp-this.globalParameters.startTimestamp,this.globalParameters.deltaX=liveVector.endPoint.x-this.globalParameters.startX,this.globalParameters.deltaY=liveVector.endPoint.y-this.globalParameters.startY;var globalVector=this.getVector(this.initialPointerEvent,this.currentPointerEvent);this.globalParameters.vector=globalVector,!0===this.DEBUG&&(console.log("[Contact] current speed: "+this.liveParameters.speed+"px/s"),console.log("[Contact] pointerdown duration: "+this.globalParameters.duration+"ms"),console.log("[Contact] live vector length within vectorTimespan: "+this.liveParameters.vector.vectorLength+"px"))}}getTimedPointerEvents(){for(var startPointerEvent=this.initialPointerEvent,endPointerEvent=this.recognizedEvents[this.recognizedEvents.length-1],startIndex=this.recognizedEvents.length-1,elapsedTime=0,endTimeStamp=endPointerEvent.timeStamp;elapsedTime<this.vectorTimespan&&!((startIndex-=1)<0);)elapsedTime=endTimeStamp-(startPointerEvent=this.recognizedEvents[startIndex]).timeStamp;var pointerEvents=[startPointerEvent,endPointerEvent];return this.recognizedEvents=this.recognizedEvents.slice(-20),pointerEvents}getVector(startPointerEvent,endPointerEvent){var vector=null;if(null!=startPointerEvent&&null!=endPointerEvent){let startPoint=new Point(startPointerEvent.clientX,startPointerEvent.clientY),endPoint=new Point(endPointerEvent.clientX,endPointerEvent.clientY);vector=new Vector(startPoint,endPoint)}return vector}getSpeed(vector,startTimestamp,endTimestamp){!0===this.DEBUG&&(console.log("[PointerInput vector] "+vector),console.log("[PointerInput startTimestamp] "+startTimestamp),console.log("[PointerInput endTimestamp] "+endTimestamp));var speed=0,timespan_s=(endTimestamp-startTimestamp)/1e3;return null!=vector&&0!=timespan_s&&(speed=vector.vectorLength/timespan_s),speed}}class Point{constructor(x,y){this.x=x,this.y=y}}class Vector{constructor(startPoint,endPoint){this.startPoint=startPoint,this.endPoint=endPoint,this.direction=DIRECTION_NONE,this.deltaX=this.endPoint.x-this.startPoint.x,this.deltaY=this.endPoint.y-this.startPoint.y,this.x=this.deltaX,this.y=this.deltaY,this.vectorLength=Math.sqrt(Math.pow(this.deltaX,2)+Math.pow(this.deltaY,2)),Math.abs(this.deltaX)>Math.abs(this.deltaY)?this.startPoint.x<this.endPoint.x?this.direction=DIRECTION_RIGHT:this.direction=DIRECTION_LEFT:this.startPoint.y<this.endPoint.y?this.direction=DIRECTION_DOWN:this.direction=DIRECTION_UP}}function deg2rad(angleDeg){return Math.PI/180*angleDeg}function rad2deg(angleRad){return angleRad/(Math.PI/180)}function getCenter(pointA,pointB){var centerX=(pointA.x+pointB.x)/2,centerY=(pointA.y+pointB.y)/2;return new Point(centerX,centerY)}function translatePoint(point,vector){var newX=point.x+vector.x,newY=point.y+vector.y;return new Point(newX,newY)}function calcAngleDegrees(point){var angle=180*Math.atan2(point.y,point.x)/Math.PI;return angle<0&&(angle=360+angle),angle}function calcAngleRad(point){var angle=Math.atan2(point.y,point.x);return angle<0&&(angle=2*Math.PI+angle),angle}class Gesture{constructor(domElement,options){this.domElement=domElement,this.isActive=!1,this.state=GESTURE_STATE_POSSIBLE,this.initialPointerEvent=null,this.boolParameters={requiresPointerMove:null,requiresActivePointer:null},this.initialMinMaxParameters={pointerCount:[null,null],duration:[null,null],currentSpeed:[null,null],averageSpeed:[null,null],finalSpeed:[null,null],distance:[null,null]},this.activeStateMinMaxParameters={pointerCount:[null,null],duration:[null,null],currentSpeed:[null,null],averageSpeed:[null,null],finalSpeed:[null,null],distance:[null,null]};let defaultOptions={bubbles:!0,blocks:[],DEBUG:!1};this.options=options||{};for(let key in defaultOptions)key in this.options||(this.options[key]=defaultOptions[key]);this.DEBUG=this.options.DEBUG}validateMinMax(minMaxParameters,parameterName,value){var minValue=minMaxParameters[parameterName][0],maxValue=minMaxParameters[parameterName][1];return 1==this.DEBUG&&console.log("[Gestures] checking "+parameterName+"[gesture.isActive: "+this.isActive.toString()+"] minValue: "+minValue+", maxValue: "+maxValue+", current value: "+value),null!=minValue&&null!=value&&value<minValue?(1==this.DEBUG&&console.log("dismissing min"+this.eventBaseName+": required "+parameterName+": "+minValue+", current value: "+value),!1):!(null!=maxValue&&null!=value&&value>maxValue)||(1==this.DEBUG&&console.log("dismissing max"+this.eventBaseName+": required "+parameterName+": "+maxValue+", current value: "+value),!1)}validateBool(parameterName,value){var requiredValue=this.boolParameters[parameterName];return null!=requiredValue&&null!=value&&requiredValue===value||(null==requiredValue||(1==this.DEBUG&&console.log("[Gestures] dismissing "+this.eventBaseName+": "+parameterName+" required: "+requiredValue+", actual value: "+value),!1))}getMinMaxParameters(contact){var primaryPointerInput=contact.getPrimaryPointerInput();return{pointerCount:Object.keys(contact.activePointerInputs).length,duration:primaryPointerInput.globalParameters.duration,currentSpeed:primaryPointerInput.liveParameters.speed,averageSpeed:primaryPointerInput.globalParameters.averageSpeed,finalSpeed:primaryPointerInput.globalParameters.finalSpeed,distance:primaryPointerInput.liveParameters.vector.vectorLength}}getBoolParameters(contact){var primaryPointerInput=contact.getPrimaryPointerInput();return{requiresPointerUp:!1===primaryPointerInput.isActive,requiresActivePointer:!0===primaryPointerInput.isActive,requiresPointerMove:!0===primaryPointerInput.globalParameters.hasBeenMoved}}validate(contact){if(this.state==GESTURE_STATE_BLOCKED)return!1;var primaryPointerInput=contact.getPrimaryPointerInput();1==this.DEBUG&&console.log("[Gestures] running recognition for "+this.eventBaseName);var contactBoolParameters=this.getBoolParameters(contact);for(let boolParameterName in this.boolParameters){let boolValue=contactBoolParameters[boolParameterName];if(0==this.validateBool(boolParameterName,boolValue))return!1}var minMaxParameters,contactMinMaxParameters=this.getMinMaxParameters(contact);minMaxParameters=1==this.isActive?this.activeStateMinMaxParameters:this.initialMinMaxParameters;for(let minMaxParameterName in minMaxParameters){let value=contactMinMaxParameters[minMaxParameterName];if(0==this.validateMinMax(minMaxParameters,minMaxParameterName,value))return!1}return!(1==Object.prototype.hasOwnProperty.call(this.options,"supportedDirections")&&this.options.supportedDirections.length>0&&-1==this.options.supportedDirections.indexOf(primaryPointerInput.liveParameters.vector.direction))||(1==this.DEBUG&&console.log("[Gestures] dismissing "+this.eventBaseName+": supported directions: "+this.options.supportedDirections+", current direction: "+primaryPointerInput.liveParameters.vector.direction),!1)}recognize(contact){var isValid=this.validate(contact);1==isValid&&0==this.isActive&&this.state==GESTURE_STATE_POSSIBLE&&this.onStart(contact),1==isValid&&1==this.isActive&&this.state==GESTURE_STATE_POSSIBLE?this.emit(contact):1==this.isActive&&0==isValid&&this.onEnd(contact)}block(gesture){-1==this.options.blocks.indexOf(gesture)&&this.options.blocks.push(gesture)}unblock(gesture){-1!=this.options.blocks.indexOf(gesture)&&this.options.blocks.splice(this.options.blocks.indexOf(gesture),1)}blockGestures(){for(let g=0;g<this.options.blocks.length;g++){let gesture=this.options.blocks[g];0==gesture.isActive&&(0==this.DEBUG&&console.log("[Gesture] blocking "+gesture.eventBaseName),gesture.state=GESTURE_STATE_BLOCKED)}}unblockGestures(){for(let g=0;g<this.options.blocks.length;g++){this.options.blocks[g].state=GESTURE_STATE_POSSIBLE}}getEventData(contact){return{contact:contact,recognizer:this}}emit(contact,eventName){eventName=eventName||this.eventBaseName,!0===this.DEBUG&&console.log("[Gestures] detected and firing event "+eventName);var eventData=this.getEventData(contact),eventOptions={detail:eventData,bubbles:this.options.bubbles},event=new CustomEvent(eventName,eventOptions),initialTarget=contact.initialPointerEvent.target;1==eventOptions.bubbles?initialTarget.dispatchEvent(event):this.domElement.dispatchEvent(event);var currentDirection=eventData.live.direction;if(1==Object.prototype.hasOwnProperty.call(this.options,"supportedDirections"))for(let d=0;d<this.options.supportedDirections.length;d++){let direction=this.options.supportedDirections[d];if(direction==currentDirection){let directionEventName=eventName+direction;1==this.DEBUG&&console.log("[Gestures] detected and firing event "+directionEventName);let directionEvent=new CustomEvent(directionEventName,eventOptions);1==eventOptions.bubbles?initialTarget.dispatchEvent(directionEvent):this.domElement.dispatchEvent(directionEvent)}}}onStart(contact){this.blockGestures(),this.isActive=!0,this.initialPointerEvent=contact.currentPointerEvent;var eventName=this.eventBaseName+"start";!0===this.DEBUG&&console.log("[Gestures] firing event: "+eventName);var eventData=this.getEventData(contact),event=new CustomEvent(eventName,{detail:eventData});this.domElement.dispatchEvent(event)}onEnd(contact){this.unblockGestures(),this.isActive=!1;var eventName=this.eventBaseName+"end";!0===this.DEBUG&&console.log("[Gestures] firing event: "+eventName);let eventData=this.getEventData(contact);var event=new CustomEvent(eventName,{detail:eventData});this.domElement.dispatchEvent(event)}onTouchStart(){}onTouchMove(){}onTouchEnd(){}onTouchCancel(){}}class SinglePointerGesture extends Gesture{constructor(domElement,options){super(domElement,options=options||{})}getEventData(contact){var eventData=super.getEventData(contact),primaryPointerInput=contact.getPrimaryPointerInput(),globalStartPoint=new Point(this.initialPointerEvent.clientX,this.initialPointerEvent.clientY),globalEndPoint=new Point(contact.currentPointerEvent.clientX,contact.currentPointerEvent.clientY),globalVector=new Vector(globalStartPoint,globalEndPoint),globalDuration=contact.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp;return eventData.global={deltaX:globalVector.x,deltaY:globalVector.y,distance:globalVector.vectorLength,speedX:globalVector.x/globalDuration,speedY:globalVector.y/globalDuration,speed:globalVector.vectorLength/globalDuration,direction:globalVector.direction,scale:1,rotation:0,srcEvent:contact.currentPointerEvent},eventData.live={deltaX:primaryPointerInput.liveParameters.vector.x,deltaY:primaryPointerInput.liveParameters.vector.y,distance:primaryPointerInput.liveParameters.vector.vectorLength,speedX:primaryPointerInput.liveParameters.vector.x/contact.vectorTimespan,speedY:primaryPointerInput.liveParameters.vector.y/contact.vectorTimespan,speed:primaryPointerInput.liveParameters.speed,direction:primaryPointerInput.liveParameters.vector.direction,scale:1,rotation:0,center:{x:primaryPointerInput.liveParameters.vector.endPoint.x,y:primaryPointerInput.liveParameters.vector.endPoint.y},srcEvent:contact.currentPointerEvent},eventData}}class Pan extends SinglePointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.eventBaseName="pan",this.initialMinMaxParameters.pointerCount=[1,1],this.initialMinMaxParameters.duration=[0,null],this.initialMinMaxParameters.distance=[10,null],this.activeStateMinMaxParameters.pointerCount=[1,1],this.boolParameters.requiresPointerMove=!0,this.boolParameters.requiresActivePointer=!0,this.swipeFinalSpeed=600,this.isSwipe=!1,this.initialSupportedDirections=DIRECTION_ALL,Object.prototype.hasOwnProperty.call(options,"supportedDirections")?this.initialSupportedDirections=options.supportedDirections:this.options.supportedDirections=DIRECTION_ALL}validate(contact){return 1==this.isActive&&(this.options.supportedDirections=DIRECTION_ALL),super.validate(contact)}onStart(contact){this.isSwipe=!1,super.onStart(contact)}onEnd(contact){var primaryPointerInput=contact.getPrimaryPointerInput();this.swipeFinalSpeed<primaryPointerInput.globalParameters.finalSpeed&&(this.isSwipe=!0,this.emit(contact,"swipe")),super.onEnd(contact),this.options.supportedDirections=this.initialSupportedDirections}onTouchMove(event){1==this.isActive&&(1==this.DEBUG&&console.log("[Pan] preventing touchmove default"),event.preventDefault(),event.stopPropagation())}}class Tap extends SinglePointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.eventBaseName="tap",this.initialMinMaxParameters.pointerCount=[0,0],this.initialMinMaxParameters.duration=[0,200],this.initialMinMaxParameters.distance=[null,30],this.boolParameters.requiresPointerMove=null,this.boolParameters.requiresActivePointer=!1}recognize(contact){1==this.validate(contact)&&this.state==GESTURE_STATE_POSSIBLE&&(this.initialPointerEvent=contact.currentPointerEvent,this.emit(contact))}}class Press extends SinglePointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.eventBaseName="press",this.initialMinMaxParameters.pointerCount=[1,1],this.initialMinMaxParameters.duration=[600,null],this.initialMinMaxParameters.distance=[null,10],this.boolParameters.requiresPointerMove=null,this.boolParameters.requiresActivePointer=!0,this.hasBeenEmitted=!1,this.hasBeenInvalidatedForContactId=null}getMinMaxParameters(contact){var minMaxParameters=super.getMinMaxParameters(contact),primaryPointerInput=contact.getPrimaryPointerInput();return minMaxParameters.distance=primaryPointerInput.globalParameters.vector.vectorLength,minMaxParameters}recognize(contact){var isValid=this.validate(contact),primaryPointerInput=contact.getPrimaryPointerInput();if(null!=this.hasBeenInvalidatedForContactId&&this.hasBeenInvalidatedForContactId!=contact.id&&(this.hasBeenInvalidatedForContactId=null),0==isValid&&primaryPointerInput.globalParameters.vector.vectorLength>this.initialMinMaxParameters.distance[1]&&(this.hasBeenInvalidatedForContactId=contact.id),1==isValid&&0==this.hasBeenEmitted&&null==this.hasBeenInvalidatedForContactId)this.initialPointerEvent=contact.currentPointerEvent,this.emit(contact),this.hasBeenEmitted=!0;else{let duration=primaryPointerInput.globalParameters.duration;1==this.hasBeenEmitted&&duration<=this.initialMinMaxParameters.duration[0]&&(this.hasBeenEmitted=!1)}}}class MultiPointerGesture extends Gesture{constructor(domElement,options){super(domElement,options=options||{}),this.boolParameters={requiresPointerMove:null,requiresActivePointer:null},this.initialMinMaxParameters={pointerCount:[2,null]},this.activeStateMinMaxParameters={pointerCount:[2,null]},this.options=options||{}}}class TwoPointerGesture extends MultiPointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.boolParameters.requiresPointerMove=!0,this.boolParameters.requiresActivePointer=!0,this.initialMinMaxParameters.pointerCount=[2,2],this.initialMinMaxParameters.centerMovement=[null,null],this.initialMinMaxParameters.distanceChange=[null,null],this.initialMinMaxParameters.rotationAngle=[null,null],this.initialMinMaxParameters.vectorAngle=[null,null],this.activeStateMinMaxParameters.pointerCount=[2,2],this.activeStateMinMaxParameters.centerMovement=[null,null],this.activeStateMinMaxParameters.distanceChange=[null,null],this.activeStateMinMaxParameters.rotationAngle=[null,null],this.activeStateMinMaxParameters.vectorAngle=[null,null]}getMinMaxParameters(contact){var minMaxParameters=super.getMinMaxParameters(contact);return minMaxParameters.centerMovement=contact.multipointer.liveParameters.centerMovement,minMaxParameters.distanceChange=Math.abs(contact.multipointer.liveParameters.distanceChange),minMaxParameters.rotationAngle=Math.abs(contact.multipointer.liveParameters.rotationAngle),minMaxParameters.vectorAngle=contact.multipointer.liveParameters.vectorAngle,minMaxParameters}getEventData(contact){var eventData=super.getEventData(contact),globalDuration=contact.currentPointerEvent.timeStamp-this.initialPointerEvent.timeStamp,globalParameters=contact.multipointer.globalParameters,liveParameters=contact.multipointer.liveParameters;return eventData.global={deltaX:globalParameters.centerMovementVector.x,deltaY:globalParameters.centerMovementVector.y,distance:globalParameters.centerMovement,speedX:globalParameters.centerMovementVector.x/globalDuration,speedY:globalParameters.centerMovementVector.y/globalDuration,speed:globalParameters.centerMovementVector.vectorLength/globalDuration,direction:globalParameters.centerMovementVector.direction,scale:globalParameters.relativeDistanceChange,rotation:globalParameters.rotationAngle,srcEvent:contact.currentPointerEvent},eventData.live={deltaX:liveParameters.centerMovementVector.x,deltaY:liveParameters.centerMovementVector.y,distance:liveParameters.centerMovement,speedX:liveParameters.centerMovementVector.x/globalDuration,speedY:liveParameters.centerMovementVector.y/globalDuration,speed:liveParameters.centerMovementVector.vectorLength/globalDuration,direction:liveParameters.centerMovementVector.direction,scale:liveParameters.relativeDistanceChange,rotation:liveParameters.rotationAngle,center:{x:liveParameters.centerMovementVector.startPoint.x,y:liveParameters.centerMovementVector.startPoint.y},srcEvent:contact.currentPointerEvent},eventData}}class Pinch extends TwoPointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.eventBaseName="pinch",this.initialMinMaxParameters.centerMovement=[0,50],this.initialMinMaxParameters.distanceChange=[5,null],this.initialMinMaxParameters.rotationAngle=[null,20],this.initialMinMaxParameters.vectorAngle=[10,null]}}class Rotate extends TwoPointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.eventBaseName="rotate",this.initialMinMaxParameters.centerMovement=[0,50],this.initialMinMaxParameters.distanceChange=[null,50],this.initialMinMaxParameters.rotationAngle=[5,null]}}class TwoFingerPan extends TwoPointerGesture{constructor(domElement,options){super(domElement,options=options||{}),this.eventBaseName="twofingerpan",this.initialMinMaxParameters.centerMovement=[3,null],this.initialMinMaxParameters.distanceChange=[null,50],this.initialMinMaxParameters.rotationAngle=[null,null],this.initialMinMaxParameters.vectorAngle=[null,150]}}var ALL_GESTURE_CLASSES=[Tap,Press,Pan,Pinch,Rotate,TwoFingerPan];class PointerListener{constructor(domElement,options){this.eventHandlers={},this.lastRecognitionTimestamp=null,this.idleRecognitionIntervalId=null,this.pointerEventHandlers={},this.touchEventHandlers={},options=options||{},this.options={bubbles:!0,handleTouchEvents:!0,DEBUG:!1,DEBUG_GESTURES:!1,DEBUG_CONTACT:!1};for(let key in options)"supportedGestures"!=key&&(this.options[key]=options[key]);this.DEBUG=this.options.DEBUG;var supportedGestures=ALL_GESTURE_CLASSES,instantiatedGestures=[];1==Object.prototype.hasOwnProperty.call(options,"supportedGestures")&&(supportedGestures=options.supportedGestures);for(let i=0;i<supportedGestures.length;i++){let gesture,GestureClass=supportedGestures[i],gestureOptions={bubbles:this.options.bubbles,DEBUG:this.options.DEBUG_GESTURES};if("function"==typeof GestureClass)gesture=new GestureClass(domElement,gestureOptions);else{if("object"!=typeof GestureClass)throw new Error("unsupported gesture type: "+typeof GestureClass);gesture=GestureClass}instantiatedGestures.push(gesture)}this.options.supportedGestures=instantiatedGestures,this.domElement=domElement,this.contact=null,this.addPointerListeners(),this.addTouchListeners()}addPointerListeners(){var self=this,domElement=this.domElement,onPointerDown=function(event){if(1==self.DEBUG&&console.log("[PointerListener] pointerdown event detected"),domElement.setPointerCapture(event.pointerId),null==self.contact||0==self.contact.isActive){let contactOptions={DEBUG:self.options.DEBUG_CONTACT};self.contact=new Contact(event,contactOptions)}else self.contact.addPointer(event);1==Object.prototype.hasOwnProperty.call(self.options,"pointerdown")&&self.options.pointerdown(event,self),null!=self.idleRecognitionIntervalId&&self.clearIdleRecognitionInterval(),self.idleRecognitionIntervalId=setInterval(function(){self.onIdle()},100)},onPointerMove=function(event){null!=self.contact&&1==self.contact.isActive&&(self.contact.onPointerMove(event),self.recognizeGestures(),1==Object.prototype.hasOwnProperty.call(self.options,"pointermove")&&self.options.pointermove(event,self))},onPointerUp=function(event){(1==self.DEBUG&&console.log("[PointerListener] pointerup event detected"),domElement.releasePointerCapture(event.pointerId),null!=self.contact&&1==self.contact.isActive)&&(self.contact.onPointerUp(event),self.recognizeGestures(),1==Object.prototype.hasOwnProperty.call(self.options,"pointerup")&&self.options.pointerup(event,self));self.clearIdleRecognitionInterval()},onPointerLeave=function(event){1==self.DEBUG&&console.log("[PointerListener] pointerleave detected"),null!=self.contact&&1==self.contact.isActive&&(self.contact.onPointerLeave(event),self.recognizeGestures()),self.clearIdleRecognitionInterval()},onPointerCancel=function(event){domElement.releasePointerCapture(event.pointerId),1==self.DEBUG&&console.log("[PointerListener] pointercancel detected"),self.contact.onPointerCancel(event),self.recognizeGestures(),self.clearIdleRecognitionInterval(),1==Object.prototype.hasOwnProperty.call(self.options,"pointercancel")&&self.options.pointercancel(event,self)};domElement.addEventListener("pointerdown",onPointerDown,{passive:!0}),domElement.addEventListener("pointermove",onPointerMove,{passive:!0}),domElement.addEventListener("pointerup",onPointerUp,{passive:!0}),domElement.addEventListener("pointerleave",onPointerLeave,{passive:!0}),domElement.addEventListener("pointercancel",onPointerCancel,{passive:!0}),this.pointerEventHandlers={pointerdown:onPointerDown,pointermove:onPointerMove,pointerup:onPointerUp,pointerleave:onPointerLeave,pointercancel:onPointerCancel}}removePointerListeners(){for(let event in this.pointerEventHandlers){let handler=this.pointerEventHandlers[event];this.domElement.removeEventListener(event,handler)}}addTouchListeners(){var self=this;if(1==self.options.handleTouchEvents){var onTouchMove=function(event){for(let g=0;g<self.options.supportedGestures.length;g++){self.options.supportedGestures[g].onTouchMove(event)}};this.domElement.addEventListener("touchmove",onTouchMove),this.touchEventHandlers={touchmove:onTouchMove}}}removeTouchListeners(){for(let event in this.touchEventHandlers){let handler=this.touchEventHandlers[event];this.domElement.removeEventListener(event,handler)}}onIdle(){if(null==this.contact||0==this.contact.isActive)this.clearIdleRecognitionInterval();else{let now=(new Date).getTime(),timedelta=null;null!=this.lastRecognitionTimestamp&&(timedelta=now-this.lastRecognitionTimestamp),(null==timedelta||timedelta>100)&&(this.contact.onIdle(),1==this.DEBUG&&console.log("[PointerListener] onIdle - running idle recognition"),this.recognizeGestures())}}clearIdleRecognitionInterval(){null!=this.idleRecognitionIntervalId&&(clearInterval(this.idleRecognitionIntervalId),this.idleRecognitionIntervalId=null)}recognizeGestures(){this.lastRecognitionTimestamp=(new Date).getTime();for(let g=0;g<this.options.supportedGestures.length;g++){this.options.supportedGestures[g].recognize(this.contact)}}parseEventsString(eventsString){return eventsString.trim().split(/\s+/g)}on(eventsString,handlerReference){let eventTypes=this.parseEventsString(eventsString);for(let e=0;e<eventTypes.length;e++){let eventType=eventTypes[e];eventType in this.eventHandlers||(this.eventHandlers[eventType]=[]),-1==this.eventHandlers[eventType].indexOf(handlerReference)&&this.eventHandlers[eventType].push(handlerReference),this.domElement.addEventListener(eventType,handlerReference,!1)}}off(eventsString,handlerReference){let eventTypes=this.parseEventsString(eventsString);for(let e=0;e<eventTypes.length;e++){let eventType=eventTypes[e];if(eventType in this.eventHandlers){let handlerReferences=this.eventHandlers[eventType],index=handlerReferences.indexOf(handlerReference);index>=0&&(handlerReferences.splice(index,1),this.eventHandlers[eventType]=handlerReferences),this.domElement.removeEventListener(eventType,handlerReference,!1)}}}destroy(){for(let event in this.eventHandlers){let handlerList=this.eventHandlers[event];for(let h=0;h<handlerList.length;h++){let handler=handlerList[h];this.domElement.removeEventListener(event,handler)}delete this.eventHandlers[event]}this.removePointerListeners(),this.removeTouchListeners()}}